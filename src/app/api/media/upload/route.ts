import { NextRequest, NextResponse } from 'next/server';
import { DIContainer } from '../../../../container/DIContainer';
import { MediaItem } from '../../../../types';
import { v4 as uuidv4 } from 'uuid';
import sharp from 'sharp';
// @ts-ignore
import * as exifParser from 'exif-parser';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    const allowedMimeTypes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'image/heic',
      'video/mp4',
      'video/webm',
      'video/mov',
      'video/quicktime'
    ];

    // iPhoneの動画ファイルはMP4として扱う
    let actualMimeType = file.type;
    if (file.type === 'video/quicktime' || file.name.toLowerCase().endsWith('.mov')) {
      actualMimeType = 'video/mp4';
    }

    if (!allowedMimeTypes.includes(file.type)) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    }

    const maxSize = 50 * 1024 * 1024; // 50MB
    if (file.size > maxSize) {
      return NextResponse.json({ error: 'File too large' }, { status: 400 });
    }

    const container = DIContainer.getInstance();
    const fileStorage = container.getFileStorage();
    const mediaRepository = container.getMediaRepository();
    const imageAnalysisService = container.getImageAnalysisService();

    const id = uuidv4();
    const fileExtension = file.name.split('.').pop() || '';
    let filename = `${id}.${fileExtension}`;

    let processedFile = file;
    let width: number | undefined;
    let height: number | undefined;
    let duration: number | undefined;
    let thumbnailPath: string | undefined;
    
    // 画像の場合はBedrockで適切なファイル名を生成 + 画像処理
    let generatedFilename = file.name;
    let autoGeneratedTags: string[] = [];
    let capturedAt: Date | null = null;
    let exifData: any = null;
    
    if (file.type.startsWith('image/')) {
      const buffer = Buffer.from(await file.arrayBuffer());
      
      // 既存のタグを取得
      const existingTags = await mediaRepository.getAllTags();
      
      // Bedrockで適切なファイル名を生成
      try {
        const intelligentName = await imageAnalysisService.generateFilename(buffer, file.type);
        generatedFilename = `${intelligentName}.${fileExtension}`;
        console.log(`Generated filename for ${file.name}: ${generatedFilename}`);
      } catch (error) {
        console.error('Failed to generate intelligent filename:', error);
        // フォールバック: 元のファイル名を使用
      }
      
      // Bedrockで自動タグを生成
      try {
        autoGeneratedTags = await imageAnalysisService.generateTags(buffer, file.type, existingTags);
        console.log(`Generated tags for ${file.name}:`, autoGeneratedTags);
      } catch (error) {
        console.error('Failed to generate tags:', error);
        // フォールバック: 空のタグ配列
      }
      
      const metadata = await sharp(buffer).metadata();
      width = metadata.width;
      height = metadata.height;

      console.log('Image metadata:', {
        width: metadata.width,
        height: metadata.height,
        orientation: metadata.orientation,
        format: metadata.format,
        size: metadata.size
      });

      // EXIF情報から撮影日時と向きを取得
      try {
        const parser = exifParser.create(buffer);
        exifData = parser.parse();
        console.log('EXIF data:', {
          orientation: exifData.tags?.Orientation,
          dateTime: exifData.tags?.DateTime,
          dateTimeOriginal: exifData.tags?.DateTimeOriginal,
          createDate: exifData.tags?.CreateDate
        });

        // 撮影日時を取得（優先度: DateTimeOriginal > CreateDate > DateTime）
        const dateTimeOriginal = exifData.tags?.DateTimeOriginal;
        const createDate = exifData.tags?.CreateDate;
        const dateTime = exifData.tags?.DateTime;
        
        if (dateTimeOriginal) {
          capturedAt = new Date(dateTimeOriginal * 1000);
        } else if (createDate) {
          capturedAt = new Date(createDate * 1000);
        } else if (dateTime) {
          capturedAt = new Date(dateTime * 1000);
        }
        
        console.log('Captured at:', capturedAt);
      } catch (error) {
        console.error('Failed to parse EXIF data:', error);
      }

      let processedBuffer = buffer;
      
      // 画像の向きを自動補正
      let sharpInstance = sharp(buffer);
      
      // EXIFの向き情報に基づいて自動回転
      if (metadata.orientation && metadata.orientation !== 1) {
        console.log('Auto-rotating image based on EXIF orientation:', metadata.orientation);
        sharpInstance = sharpInstance.rotate(); // sharpが自動的にEXIF orientationを適用
      }
      
      if (file.size > 2 * 1024 * 1024) { // 2MB以上は圧縮
        processedBuffer = await sharpInstance
          .resize(2048, 2048, { fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 85 })
          .toBuffer();
      } else {
        // 圧縮しない場合でも回転処理を適用
        processedBuffer = await sharpInstance.toBuffer();
      }
      
      // 回転後のメタデータを再取得
      const finalMetadata = await sharp(processedBuffer).metadata();
      width = finalMetadata.width;
      height = finalMetadata.height;
      
      console.log('Final image metadata after processing:', {
        width: finalMetadata.width,
        height: finalMetadata.height,
        orientation: finalMetadata.orientation
      });

      processedFile = new File([processedBuffer], filename, { type: file.type });
    } else if (file.type.startsWith('video/')) {
      // 動画の場合はそのまま保存（サムネイルはフロントエンドで生成）
      // 動画ファイル名を変更してMP4として保存
      if (file.type === 'video/quicktime') {
        const newFilename = `${id}.mp4`;
        filename = newFilename;
        processedFile = new File([await file.arrayBuffer()], newFilename, { type: 'video/mp4' });
      }
    }

    const savedPath = await fileStorage.save(processedFile, filename);

    const currentTime = new Date();
    const mediaItem: MediaItem = {
      id,
      filename,
      originalFilename: generatedFilename, // Bedrockで生成されたファイル名を使用
      mimeType: actualMimeType,
      size: processedFile.size,
      width,
      height,
      duration,
      thumbnailPath,
      createdAt: capturedAt || currentTime, // 撮影日時があればそれを使用、なければ現在時刻
      updatedAt: currentTime,
      tags: autoGeneratedTags,
      metadata: {
        exif: exifData,
        location: undefined,
      },
    };

    await mediaRepository.save(mediaItem);

    return NextResponse.json({
      success: true,
      mediaItem,
    });
  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json({ error: 'Upload failed' }, { status: 500 });
  }
}